---
// PasskeyConnector.astro - WebAuthn (Passkey) UI component for Soroban integration

interface Props {
  title?: string;
  showDebug?: boolean;
}

const { title = 'Autenticaci√≥n Passkey', showDebug = false } = Astro.props as Props;
---

<div id="passkey-connector" class="passkey-container">
  <div class="passkey-card">
    <div class="flex items-center justify-center gap-3 mb-6">
      <span class="text-3xl">üîê</span>
      <h2 class="text-2xl font-bold text-white">{title}</h2>
    </div>
    
    <div class="passkey-actions grid gap-3">
      <button id="register-btn" class="btn-primary w-full">
        üì± Registrar Passkey
      </button>
      <button id="authenticate-btn" class="btn-secondary w-full">
        ‚úÖ Autenticar
      </button>
      <button id="clear-btn" class="btn-danger w-full">
        üóëÔ∏è Limpiar Sesi√≥n
      </button>
    </div>

    <div id="status" class="status-message mt-4 text-sm rounded-lg p-3 min-h-10"></div>

    {showDebug && (
      <div class="debug-section mt-6 bg-white/5 border border-white/10 rounded-lg p-4">
        <h3 class="text-sm font-bold text-gray-300 mb-2">Debug Info</h3>
        <pre id="debug-output" class="text-xs bg-black/30 p-3 rounded overflow-y-auto max-h-40 text-gray-400"></pre>
      </div>
    )}
  </div>
</div>

<script type="module">
  // Cargar el API base desde el frontend
  const API_BASE = 'http://localhost:3000/api';

  // Funciones auxiliares para codificaci√≥n
  function toBase64Url(buffer) {
    const bytes = new Uint8Array(buffer);
    let str = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      str += String.fromCharCode(bytes[i]);
    }
    return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  function fromBase64Url(base64url) {
    const padding = '='.repeat((4 - (base64url.length % 4)) % 4);
    const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/') + padding;
    const str = atob(base64);
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) bytes[i] = str.charCodeAt(i);
    return bytes;
  }

  // Funci√≥n para registrar passkey
  async function registerPasskey(opts) {
    if (!window.PublicKeyCredential) {
      throw new Error('WebAuthn no es soportado en este navegador');
    }

    try {
      // PASO 1: Obtener opciones del backend
      appendDebug('[PASO 1] Solicitando challenge al servidor...');
      console.log('[PasskeyConnector] PASO 1: Obteniendo opciones de registro');
      
      const t1 = performance.now();
      const optionsResponse = await fetch(`${API_BASE}/passkey/register/options`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: opts.name,
          displayName: opts.displayName || opts.name
        })
      });

      if (!optionsResponse.ok) {
        throw new Error('Error obteniendo opciones de registro');
      }

      const { challenge, sessionId, userId } = await optionsResponse.json();
      const t2 = performance.now();
      appendDebug(`[PASO 1] ‚úì Challenge recibido en ${(t2-t1).toFixed(0)}ms`);

      // PASO 2: Preparar credencial para WebAuthn
      appendDebug('[PASO 2] Preparando credencial WebAuthn...');
      const publicKey = {
        challenge: new Uint8Array(challenge),
        rp: {
          name: 'CenVote dApp',
          id: window.location.hostname
        },
        user: {
          id: new TextEncoder().encode(opts.id),
          name: opts.name,
          displayName: opts.displayName || opts.name
        },
        pubKeyCredParams: [
          { alg: -7, type: 'public-key' },
          { alg: -257, type: 'public-key' }
        ],
        authenticatorSelection: {
          authenticatorAttachment: 'platform',
          userVerification: 'required',
          residentKey: 'preferred'
        },
        timeout: 60000,
        attestation: 'none'
      };

      // PASO 3: Mostrar prompt biom√©trico
      appendDebug('[PASO 3] Mostrar prompt de autenticaci√≥n biom√©trica (tu huella, Face ID, etc)...');
      appendDebug('‚è≥ En espera de acci√≥n biom√©trica del usuario...');
      console.log('[PasskeyConnector] PASO 3: Esperando credencial del usuario');
      
      const t3 = performance.now();
      const cred = await navigator.credentials.create({ publicKey });

      if (!cred) {
        throw new Error('No se pudo crear la credencial - operaci√≥n cancelada');
      }

      const t4 = performance.now();
      const attResp = cred.response;
      appendDebug(`[PASO 3] ‚úì Credencial creada en ${(t4-t3).toFixed(0)}ms`);

      // PASO 4: Enviar credencial al backend para verificaci√≥n
      appendDebug('[PASO 4] Verificando credencial con el servidor...');
      console.log('[PasskeyConnector] PASO 4: Verificando credencial');
      
      const t5 = performance.now();
      const verifyResponse = await fetch(`${API_BASE}/passkey/register/verify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sessionId,
          credentialId: toBase64Url(cred.rawId),
          publicKey: toBase64Url(attResp.attestationObject),
          username: opts.name,
          displayName: opts.displayName || opts.name,
          aaguid: ''
        })
      });

      if (!verifyResponse.ok) {
        const error = await verifyResponse.json();
        throw new Error(error.error || 'Error verificando credencial');
      }

      const result = await verifyResponse.json();
      const t6 = performance.now();
      appendDebug(`[PASO 4] ‚úì Credencial verificada en ${(t6-t5).toFixed(0)}ms`);
      
      // PASO 5: Guardar datos en localStorage
      appendDebug('[PASO 5] Guardando datos de sesi√≥n...');
      if (result.userId) {
        localStorage.setItem('passkey_user_id', result.userId);
        localStorage.setItem('passkey_username', result.username);
        localStorage.setItem('passkey_display_name', result.displayName);
      }
      appendDebug(`[PASO 5] ‚úì Datos guardados`);

      console.log('[PasskeyConnector] ‚úì Registro exitoso');

      return {
        id: cred.id,
        rawId: toBase64Url(cred.rawId),
        clientDataJSON: toBase64Url(attResp.clientDataJSON),
        attestationObject: toBase64Url(attResp.attestationObject)
      };
    } catch (error) {
      console.error('[PasskeyConnector] Error:', error);
      throw error;
    }
  }

  // Funci√≥n para autenticar con passkey
  async function authenticatePasskey() {
    if (!window.PublicKeyCredential) {
      throw new Error('WebAuthn no es soportado en este navegador');
    }

    try {
      // PASO 1: Obtener challenge del backend
      appendDebug('[PASO 1] Solicitando challenge de autenticaci√≥n...');
      console.log('[PasskeyConnector] PASO 1: Obteniendo opciones de autenticaci√≥n');
      
      const t1 = performance.now();
      const optionsResponse = await fetch(`${API_BASE}/passkey/authenticate/options`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });

      if (!optionsResponse.ok) {
        throw new Error('Error obteniendo challenge de autenticaci√≥n');
      }

      const { challenge, sessionId } = await optionsResponse.json();
      const t2 = performance.now();
      appendDebug(`[PASO 1] ‚úì Challenge recibido en ${(t2-t1).toFixed(0)}ms`);

      // PASO 2: Preparar credencial para WebAuthn
      appendDebug('[PASO 2] Preparando autenticaci√≥n...');
      const publicKey = {
        challenge: new Uint8Array(challenge),
        timeout: 60000,
        userVerification: 'required',
        allowCredentials: []
      };

      // PASO 3: Mostrar prompt biom√©trico
      appendDebug('[PASO 3] Mostrar prompt biom√©trico para autenticaci√≥n...');
      appendDebug('‚è≥ En espera de tu huella o Face ID...');
      console.log('[PasskeyConnector] PASO 3: Esperando autenticaci√≥n del usuario');

      const t3 = performance.now();
      const assertion = await navigator.credentials.get({ publicKey });

      if (!assertion) {
        throw new Error('No se pudo obtener una aserci√≥n - operaci√≥n cancelada');
      }

      const t4 = performance.now();
      const authResp = assertion.response;
      appendDebug(`[PASO 3] ‚úì Autenticaci√≥n realizada en ${(t4-t3).toFixed(0)}ms`);

      // PASO 4: Verificar autenticaci√≥n en el backend
      appendDebug('[PASO 4] Verificando autenticaci√≥n con el servidor...');
      console.log('[PasskeyConnector] PASO 4: Verificando aserci√≥n');
      
      const t5 = performance.now();
      const verifyResponse = await fetch(`${API_BASE}/passkey/authenticate/verify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sessionId,
          credentialId: toBase64Url(assertion.rawId),
          username: localStorage.getItem('passkey_username') || ''
        })
      });

      if (!verifyResponse.ok) {
        const error = await verifyResponse.json();
        throw new Error(error.error || 'Error en autenticaci√≥n');
      }

      const result = await verifyResponse.json();
      const t6 = performance.now();
      appendDebug(`[PASO 4] ‚úì Autenticaci√≥n verificada en ${(t6-t5).toFixed(0)}ms`);
      
      // PASO 5: Guardar token de sesi√≥n
      appendDebug('[PASO 5] Guardando token de sesi√≥n...');
      if (result.authToken) {
        localStorage.setItem('auth_token', result.authToken);
        localStorage.setItem('passkey_user_id', result.userId);
        localStorage.setItem('passkey_username', result.username);
        localStorage.setItem('passkey_display_name', result.displayName);
      }
      appendDebug(`[PASO 5] ‚úì Sesi√≥n iniciada`);

      console.log('[PasskeyConnector] ‚úì Autenticaci√≥n exitosa');

      return {
        id: assertion.id,
        rawId: toBase64Url(assertion.rawId),
        clientDataJSON: toBase64Url(authResp.clientDataJSON),
        authenticatorData: toBase64Url(authResp.authenticatorData),
        signature: toBase64Url(authResp.signature),
        userHandle: authResp.userHandle ? toBase64Url(authResp.userHandle) : null
      };
    } catch (error) {
      console.error('[PasskeyConnector] Error:', error);
      throw error;
    }
  }

  // Funci√≥n para verificar disponibilidad
  async function isPasskeyAvailable() {
    try {
      if (!window.PublicKeyCredential) {
        return false;
      }
      
      const isUserVerifyingPlatformAuthenticatorAvailable =
        await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.();
      
      return isUserVerifyingPlatformAuthenticatorAvailable !== false;
    } catch {
      return false;
    }
  }

  // === SETUP DE EVENTOS ===
  const registerBtn = document.getElementById('register-btn');
  const authenticateBtn = document.getElementById('authenticate-btn');
  const clearBtn = document.getElementById('clear-btn');
  const statusDiv = document.getElementById('status');
  const debugOutput = document.getElementById('debug-output');

  console.log('[PasskeyConnector] Elementos encontrados:', {
    registerBtn: !!registerBtn,
    authenticateBtn: !!authenticateBtn,
    clearBtn: !!clearBtn,
    statusDiv: !!statusDiv
  });

  function showStatus(message, type) {
    if (statusDiv) {
      statusDiv.textContent = message;
      statusDiv.className = `status-message mt-4 text-sm rounded-lg p-3 min-h-10 ${
        type === 'success' ? 'bg-emerald-500/20 border border-emerald-500/50 text-emerald-300' :
        type === 'error' ? 'bg-red-500/20 border border-red-500/50 text-red-300' :
        type === 'warning' ? 'bg-yellow-500/20 border border-yellow-500/50 text-yellow-300' :
        'bg-blue-500/20 border border-blue-500/50 text-blue-300'
      }`;
    }
    console.log(`[${type.toUpperCase()}] ${message}`);
  }

  function appendDebug(text) {
    if (debugOutput) {
      debugOutput.textContent += text + '\n';
      debugOutput.parentElement?.scrollTo(0, debugOutput.scrollHeight);
    }
  }

  if (registerBtn) {
    registerBtn.addEventListener('click', async () => {
      try {
        registerBtn.disabled = true;
        showStatus('‚è≥ Registrando passkey...', 'info');
        appendDebug('[REGISTER] Iniciando registro de passkey...');

        const userName = prompt('Ingresa tu nombre de usuario:', 'Usuario') || 'Usuario';
        if (!userName) {
          showStatus('‚ùå Se requiere un nombre de usuario', 'error');
          registerBtn.disabled = false;
          return;
        }

        const result = await registerPasskey({
          id: `user-${Date.now()}`,
          name: userName,
          displayName: userName
        });

        appendDebug(`[REGISTER] ‚úì Credencial registrada: ${result.id.substring(0, 20)}...`);
        showStatus(`‚úÖ Passkey registrado para ${userName}. Puedes autenticarte ahora.`, 'success');
        
        window.dispatchEvent(new CustomEvent('passkeyRegistered', {
          detail: { userId: result.id, userName }
        }));

      } catch (err) {
        const error = err instanceof Error ? err.message : String(err);
        appendDebug(`[ERROR] ${error}`);
        showStatus(`‚ùå Error: ${error}`, 'error');
      } finally {
        registerBtn.disabled = false;
      }
    });
  }

  if (authenticateBtn) {
    authenticateBtn.addEventListener('click', async () => {
      try {
        authenticateBtn.disabled = true;
        showStatus('‚è≥ Autenticando con passkey...', 'info');
        appendDebug('[AUTH] Iniciando autenticaci√≥n...');

        const result = await authenticatePasskey();

        appendDebug(`[AUTH] ‚úì Autenticaci√≥n exitosa: ${result.id.substring(0, 20)}...`);
        showStatus(`‚úÖ ¬°Autenticado exitosamente!`, 'success');

        // Mostrar datos del usuario autenticado
        const userName = localStorage.getItem('passkey_username');
        if (userName) {
          setTimeout(() => {
            showStatus(`‚úÖ Bienvenido ${userName}!`, 'success');
          }, 500);
        }

        window.dispatchEvent(new CustomEvent('passkeyAuthenticated', {
          detail: {
            assertionId: result.id,
            signature: result.signature,
            clientDataJSON: result.clientDataJSON
          }
        }));

      } catch (err) {
        const error = err instanceof Error ? err.message : String(err);
        appendDebug(`[ERROR] ${error}`);
        showStatus(`‚ùå Error: ${error}`, 'error');
      } finally {
        authenticateBtn.disabled = false;
      }
    });
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      if (confirm('¬øLimpiar datos de sesi√≥n?')) {
        localStorage.removeItem('auth_token');
        localStorage.removeItem('passkey_user_id');
        localStorage.removeItem('passkey_username');
        localStorage.removeItem('passkey_display_name');
        appendDebug('[CLEAR] Sesi√≥n limpiada');
        showStatus('‚úÖ Sesi√≥n limpiada correctamente', 'success');
      }
    });
  }

  // Verificar disponibilidad de WebAuthn al cargar
  (async () => {
    const available = await isPasskeyAvailable();
    appendDebug(`[INIT] WebAuthn disponible: ${available}`);
    if (!available) {
      showStatus('‚ö†Ô∏è WebAuthn no disponible en este navegador', 'warning');
      if (registerBtn) registerBtn.disabled = true;
      if (authenticateBtn) authenticateBtn.disabled = true;
    }
    
    // Mostrar si hay sesi√≥n activa
    const currentUser = localStorage.getItem('passkey_username');
    if (currentUser) {
      appendDebug(`[INIT] Usuario activo: ${currentUser}`);
      showStatus(`‚úÖ Sesi√≥n activa: ${currentUser}`, 'success');
    }
  })();

  console.log('[PasskeyConnector] Script inicializado');
</script>

