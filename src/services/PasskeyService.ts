// Minimal WebAuthn (Passkey) helpers for Soroban integration
// Note: In production, the challenge must be generated by your backend and verified there.

function toBase64Url(buffer: ArrayBuffer) {
  const bytes = new Uint8Array(buffer);
  let str = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function fromBase64Url(base64url: string): Uint8Array {
  const padding = '='.repeat((4 - (base64url.length % 4)) % 4);
  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/') + padding;
  const str = atob(base64);
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) bytes[i] = str.charCodeAt(i);
  return bytes;
}

function randomChallenge(length = 32) {
  const arr = new Uint8Array(length);
  crypto.getRandomValues(arr);
  return arr;
}

export async function registerPasskey(opts: {
  id: string; // user id (string) - will be converted to Uint8Array
  name: string;
  displayName?: string;
}) {
  const userId = new TextEncoder().encode(opts.id);
  const challenge = randomChallenge(32);

  const publicKey: PublicKeyCredentialCreationOptions = {
    challenge,
    rp: { name: 'CenVote dApp' },
    user: { id: userId, name: opts.name, displayName: opts.displayName || opts.name },
    pubKeyCredParams: [{ alg: -7, type: 'public-key' }], // ES256 (secp256r1)
    authenticatorSelection: {
      authenticatorAttachment: 'platform',
      userVerification: 'required'
    },
    timeout: 60000,
    attestation: 'none'
  } as any;

  const cred = (await navigator.credentials.create({ publicKey } as any)) as PublicKeyCredential | null;
  if (!cred) throw new Error('No credential created');

  const attResp: any = cred.response as any;
  return {
    id: cred.id,
    rawId: toBase64Url(cred.rawId as ArrayBuffer),
    clientDataJSON: toBase64Url(attResp.clientDataJSON),
    attestationObject: toBase64Url(attResp.attestationObject)
  };
}

export async function authenticatePasskey(serverChallenge: string | Uint8Array) {
  // serverChallenge must be provided by your backend (base64url or raw bytes)
  const challengeBytes = typeof serverChallenge === 'string' ? fromBase64Url(serverChallenge) : serverChallenge;

  const publicKey: PublicKeyCredentialRequestOptions = {
    challenge: challengeBytes,
    timeout: 60000,
    userVerification: 'required'
  } as any;

  const assertion = (await navigator.credentials.get({ publicKey } as any)) as PublicKeyCredential | null;
  if (!assertion) throw new Error('No assertion returned');

  const authResp: any = assertion.response as any;
  return {
    id: assertion.id,
    rawId: toBase64Url(assertion.rawId as ArrayBuffer),
    clientDataJSON: toBase64Url(authResp.clientDataJSON),
    authenticatorData: toBase64Url(authResp.authenticatorData),
    signature: toBase64Url(authResp.signature),
    userHandle: authResp.userHandle ? toBase64Url(authResp.userHandle) : null
  };
}

// Utility exports for callers
export const PasskeyUtils = {
  toBase64Url,
  fromBase64Url
};
